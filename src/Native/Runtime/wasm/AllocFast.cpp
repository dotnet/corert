// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

#include <AsmOffsets.inc>         // generated by the build from AsmOffsets.cpp
#include <cassert>

// TODO: Implement these to allow allocation through the runtime. See AllocFast.s under other architectures for how
// each function should work. This file should ideally be pure WebAssembly for better speed.

// Allocate non-array, non-finalizable object. If the allocation doesn't fit into the current thread's
// allocation context then automatically fallback to the slow allocation path.
extern "C" void* RhpNewFast(void* eeType)
{
    assert(false);
    return nullptr;
}


// Allocate non-array object with finalizer.
//  r0 == EEType
//
extern "C" void* RhpNewFinalizable(void* eeType)
{
    assert(false);
    return nullptr;
}

// Allocate non-array object.
extern "C" void* RhpNewObject(void* eeType, unsigned int allocFlags)
{
    assert(false);
    return nullptr;
}

// Allocate a string.
extern "C" void* RhNewString(void* eeType, int elementCount)
{
    assert(false);
    return nullptr;
}

// Allocate one dimensional, zero based array (SZARRAY).
extern "C" void* RhpNewArray(void* eeType, int elementCount)
{
    assert(false);
    return nullptr;
}

// Allocate one dimensional, zero based array (SZARRAY) using the slow path that calls a runtime helper.
extern "C" void* RhpNewArrayRare(void* eeType, int elementCount, int arraySize, int thread)
{
    assert(false);
    return nullptr;
}

// Allocate simple object (not finalizable, array or value type) on an 8 byte boundary.
extern "C" void* RhpNewFastAlign8(void* eeType)
{
    assert(false);
    return nullptr;
}

// Allocate a finalizable object (by definition not an array or value type) on an 8 byte boundary.
extern "C" void* RhpNewFinalizableAlign8(void* eeType)
{
    assert(false);
    return nullptr;
}

// Allocate a value type object (i.e. box it) on an 8 byte boundary + 4 (so that the value type payload
// itself is 8 byte aligned).
extern "C" void* RhpNewFastMisalign(void* eeType)
{
    assert(false);
    return nullptr;
}

// Allocate an array on an 8 byte boundary.
extern "C" void* RhpNewArrayAlign8(void* eeType, int elementCount)
{
    assert(false);
    return nullptr;
}
