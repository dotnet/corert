;;
;; Copyright (c) Microsoft. All rights reserved.
;; Licensed under the MIT license. See LICENSE file in the project root for full license information. 
;;

include AsmOffsets.inc      ; generated by the build from AsmOffsets.cpp

;;
;; MACROS
;;

FASTCALL_FUNC macro FuncName,cbArgs
    FuncNameReal EQU @&FuncName&@&cbArgs
    FuncNameReal proc public
endm

FASTCALL_ENDFUNC macro
    FuncNameReal endp
endm

ALTERNATE_ENTRY macro Name

decoratedName TEXTEQU @CatStr( _, Name ) )

decoratedName label proc
PUBLIC decoratedName
        endm

__tls_array     equ 2Ch     ;; offsetof(TEB, ThreadLocalStoragePointer)

;;
;; __declspec(thread) version
;;
INLINE_GETTHREAD macro destReg, trashReg
    ASSUME fs : NOTHING
    EXTERN __tls_index : DWORD

    mov         destReg, [__tls_index]
    mov         trashReg, fs:[__tls_array]
    mov         destReg, [trashReg + destReg * 4]
    add         destReg, OFFSETOF__TLS__tls_CurrentThread
endm


INLINE_THREAD_UNHIJACK macro threadReg, trashReg1, trashReg2
        ;;
        ;; Thread::Unhijack()
        ;;
        mov         trashReg1, [threadReg + OFFSETOF__Thread__m_pvHijackedReturnAddress]
        cmp         trashReg1, 0
        je          @F

        mov         trashReg2, [threadReg + OFFSETOF__Thread__m_ppvHijackedReturnAddressLocation]
        mov         [trashReg2], trashReg1
        mov         dword ptr [threadReg + OFFSETOF__Thread__m_ppvHijackedReturnAddressLocation], 0
        mov         dword ptr [threadReg + OFFSETOF__Thread__m_pvHijackedReturnAddress], 0

@@:
endm

;;
;; Macro used from unmanaged helpers called from managed code where the helper does not transition immediately
;; into pre-emptive mode but may cause a GC and thus requires the stack is crawlable. This is typically the
;; case for helpers that meddle in GC state (e.g. allocation helpers) where the code must remain in
;; cooperative mode since it handles object references and internal GC state directly but a garbage collection
;; may be inevitable. In these cases we need to be able to transition to pre-meptive mode deep within the
;; unmanaged code but still be able to initialize the stack iterator at the first stack frame which may hold
;; interesting GC references. In all our helper cases this corresponds to the most recent managed frame (e.g.
;; the helper's caller).
;;
;; This macro builds a frame describing the current state of managed code and stashes a pointer to this frame
;; on the current thread, ready to be used if and when the helper needs to transition to pre-emptive mode.
;;
;; The macro assumes it is called from a helper that has already set up an EBP frame and that the values of
;; EBX, ESI and EDI remain unchanged from their values in managed code. It pushes the frame at the top of the
;; stack.
;;
;; EAX is trashed by this macro.
;;
PUSH_COOP_PINVOKE_FRAME macro threadReg
    lea         eax, [ebp + 8]                      ; get the ESP of the caller
    push        eax                                 ; save ESP
    push        edi
    push        esi
    push        ebx
    push        PTFF_SAVE_ALL_PRESERVED + PTFF_SAVE_RSP
    push        threadReg                           ; Thread * (unused by stackwalker)
    mov         eax, [ebp + 0]                      ; Find previous EBP value
    push        eax                                 ; save EBP
    mov         eax, [ebp + 4]                      ; Find the return address
    push        eax                                 ; save m_RIP

    lea         eax, [esp + 0]                      ; EAX == address of frame
    mov         [threadReg + OFFSETOF__Thread__m_pHackPInvokeTunnel], eax ; Link frame to thread
endm

;;
;; Remove the frame from a previous call to PUSH_COOP_PINVOKE_FRAME from the top of the stack and restore EBX,
;; ESI and EDI to their previous values.
;;
;; TRASHES ECX
;;
POP_COOP_PINVOKE_FRAME macro
    ;; We do not need to clear m_pHackPInvokeTunnel here because it is 'on the side' information.
    ;; The actual transition to/from preemptive mode is done elsewhere (HackEnablePreemptiveMode,
    ;; HackDisablePreemptiveMode) and m_pHackPInvokeTunnel need only be valid when that happens,
    ;; so as long as we always set it on the way into a "cooperative pinvoke" method, we're fine
    ;; because it is only looked at inside these "cooperative pinvoke" methods.
    add         esp, 4*4
    pop         ebx
    pop         esi
    pop         edi
    pop         ecx 
endm


;;
;; CONSTANTS -- INTEGER
;;
TSF_Attached                    equ 01h
TSF_SuppressGcStress            equ 08h
TSF_DoNotTriggerGc              equ 10h

;; Slot number of the Finalize virtual method.
METHOD_SLOT_Finalize            equ 0

;; GC type flags
GC_ALLOC_FINALIZE               equ 1

;; Note: these must match the defs in PInvokeTransitionFrameFlags
PTFF_SAVE_RBX           equ 00000001h
PTFF_SAVE_RSI           equ 00000002h
PTFF_SAVE_RDI           equ 00000004h
PTFF_SAVE_ALL_PRESERVED equ 00000007h   ;; NOTE: RBP is not included in this set!
PTFF_SAVE_RSP           equ 00008000h
PTFF_SAVE_RAX           equ 00000100h   ;; RAX is saved if it contains a GC ref and we're in hijack handler
PTFF_SAVE_ALL_SCRATCH   equ 00000700h
PTFF_RAX_IS_GCREF       equ 00010000h   ;; iff PTFF_SAVE_RAX: set -> eax is Object, clear -> eax is scalar
PTFF_RAX_IS_BYREF       equ 00020000h   ;; iff PTFF_SAVE_RAX: set -> eax is ByRef, clear -> eax is Object or scalar

;;
;; Offset from FP (ebp) where the managed callout thunk (ManagedCallout2 and possibly others in the future)
;; store a pointer to a transition frame.
;;
MANAGED_CALLOUT_THUNK_TRANSITION_FRAME_POINTER_OFFSET equ -4

;;
;; This constant, unfortunately, cannot be validated at build time.
;;
OFFSETOF__TLS__tls_CurrentThread                    equ  8h

;;
;; Rename fields of nested structs
;;
OFFSETOF__Thread__m_alloc_context__alloc_ptr        equ OFFSETOF__Thread__m_rgbAllocContextBuffer + OFFSETOF__alloc_context__alloc_ptr
OFFSETOF__Thread__m_alloc_context__alloc_limit      equ OFFSETOF__Thread__m_rgbAllocContextBuffer + OFFSETOF__alloc_context__alloc_limit

;;
;; CONSTANTS -- SYMBOLS
;;

PALDEBUGBREAK                               equ ?PalDebugBreak@@YGXXZ
REDHAWKGCINTERFACE__ALLOC                   equ ?Alloc@RedhawkGCInterface@@SGPAXPAVThread@@IIPAVEEType@@@Z
REDHAWKGCINTERFACE__GARBAGECOLLECT          equ ?GarbageCollect@RedhawkGCInterface@@SGXII@Z
G_LOWEST_ADDRESS                            equ _g_lowest_address
G_HIGHEST_ADDRESS                           equ _g_highest_address
G_EPHEMERAL_LOW                             equ _g_ephemeral_low
G_EPHEMERAL_HIGH                            equ _g_ephemeral_high
G_CARD_TABLE                                equ _g_card_table
THREADSTORE__ATTACHCURRENTTHREAD            equ ?AttachCurrentThread@ThreadStore@@SGXXZ
RhpPInvokeWaitEx                            equ @RhpPInvokeWaitEx@4
RhpPInvokeReturnWaitEx                      equ @RhpPInvokeReturnWaitEx@4
RhpTrapThreads                              equ _RhpTrapThreads
RhpPublishObject                            equ @RhpPublishObject@8

ifdef FEATURE_GC_STRESS
THREAD__HIJACKFORGCSTRESS                   equ ?HijackForGcStress@Thread@@SGXPAUPAL_LIMITED_CONTEXT@@@Z
REDHAWKGCINTERFACE__STRESSGC                equ ?StressGc@RedhawkGCInterface@@SGXXZ
endif ;; FEATURE_GC_STRESS

;;
;; IMPORTS
;;
EXTERN REDHAWKGCINTERFACE__ALLOC                : PROC
EXTERN REDHAWKGCINTERFACE__GARBAGECOLLECT       : PROC
EXTERN THREADSTORE__ATTACHCURRENTTHREAD         : PROC
EXTERN PALDEBUGBREAK                            : PROC
EXTERN RhpPInvokeWaitEx                         : PROC
EXTERN RhpPInvokeReturnWaitEx                   : PROC
EXTERN RhExceptionHandling_FailedAllocation     : PROC
EXTERN RhpPublishObject                         : PROC
EXTERN RhpCalculateStackTraceWorker             : PROC
EXTERN RhThrowHwEx                              : PROC
EXTERN RhThrowEx                                : PROC
EXTERN RhRethrow                                : PROC

ifdef FEATURE_GC_STRESS
EXTERN THREAD__HIJACKFORGCSTRESS                : PROC
EXTERN REDHAWKGCINTERFACE__STRESSGC             : PROC
endif ;; FEATURE_GC_STRESS

EXTERN G_LOWEST_ADDRESS : DWORD
EXTERN G_HIGHEST_ADDRESS : DWORD
EXTERN G_EPHEMERAL_LOW : DWORD
EXTERN G_EPHEMERAL_HIGH : DWORD
EXTERN G_CARD_TABLE : DWORD
EXTERN RhpTrapThreads : DWORD
