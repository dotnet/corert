<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CancellationToken_CreateLinkedToken_TokensIsEmpty" xml:space="preserve">
    <value>No tokens were supplied.</value>
  </data>
  <data name="CancellationTokenSource_Disposed" xml:space="preserve">
    <value>The CancellationTokenSource has been disposed.</value>
  </data>
  <data name="CancellationToken_SourceDisposed" xml:space="preserve">
    <value>The CancellationTokenSource associated with this CancellationToken has been disposed.</value>
  </data>
  <data name="OperationCanceled" xml:space="preserve">
    <value>The operation was canceled.</value>
  </data>
  <data name="AsyncMethodBuilder_InstanceNotInitialized" xml:space="preserve">
    <value>The builder was not properly initialized.</value>
  </data>
  <data name="CountdownEvent_Increment_AlreadyZero" xml:space="preserve">
    <value>The event is already signaled and cannot be incremented.</value>
  </data>
  <data name="CountdownEvent_Increment_AlreadyMax" xml:space="preserve">
    <value>The increment operation would cause the CurrentCount to overflow.</value>
  </data>
  <data name="CountdownEvent_Decrement_BelowZero" xml:space="preserve">
    <value>Invalid attempt made to decrement the event's count below zero.</value>
  </data>
  <data name="Common_OperationCanceled" xml:space="preserve">
    <value>The operation was canceled.</value>
  </data>
  <data name="Barrier_Dispose" xml:space="preserve">
    <value>The barrier has been disposed.</value>
  </data>
  <data name="Barrier_SignalAndWait_InvalidOperation_ZeroTotal" xml:space="preserve">
    <value>The barrier has no registered participants.</value>
  </data>
  <data name="Barrier_SignalAndWait_ArgumentOutOfRange" xml:space="preserve">
    <value>The specified timeout must represent a value between -1 and Int32.MaxValue, inclusive.</value>
  </data>
  <data name="Barrier_RemoveParticipants_InvalidOperation" xml:space="preserve">
    <value>The participantCount argument is greater than the number of participants that haven't yet arrived at the barrier in this phase.</value>
  </data>
  <data name="Barrier_RemoveParticipants_ArgumentOutOfRange" xml:space="preserve">
    <value>The participantCount argument must be less than or equal the number of participants.</value>
  </data>
  <data name="Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange" xml:space="preserve">
    <value>The participantCount argument must be a positive value.</value>
  </data>
  <data name="Barrier_InvalidOperation_CalledFromPHA" xml:space="preserve">
    <value>This method may not be called from within the postPhaseAction.</value>
  </data>
  <data name="Barrier_AddParticipants_NonPositive_ArgumentOutOfRange" xml:space="preserve">
    <value>The participantCount argument must be a positive value.</value>
  </data>
  <data name="Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded" xml:space="preserve">
    <value>The number of threads using the barrier exceeded the total number of registered participants.</value>
  </data>
  <data name="BarrierPostPhaseException" xml:space="preserve">
    <value>The postPhaseAction failed with an exception.</value>
  </data>
  <data name="Barrier_ctor_ArgumentOutOfRange" xml:space="preserve">
    <value>The participantCount argument must be non-negative and less than or equal to 32767.</value>
  </data>
  <data name="Barrier_AddParticipants_Overflow_ArgumentOutOfRange" xml:space="preserve">
    <value>Adding participantCount participants would result in the number of participants exceeding the maximum number allowed.</value>
  </data>
  <data name="InvalidOperation_CannotSupressFlowMultipleTimes" xml:space="preserve">
    <value>Context flow is already suppressed.</value>
  </data>
  <data name="InvalidOperation_CannotCopyUsedContext" xml:space="preserve">
    <value>Only newly captured contexts can be copied</value>
  </data>
  <data name="InvalidOperation_NullContext" xml:space="preserve">
    <value>Cannot call Set on a null context</value>
  </data>
  <data name="InvalidOperation_CannotRestoreUnsupressedFlow" xml:space="preserve">
    <value>Cannot restore context flow when it is not suppressed.</value>
  </data>
  <data name="InvalidOperation_NotNewCaptureContext" xml:space="preserve">
    <value>Cannot apply a context that has been marshaled across AppDomains, that was not acquired through a Capture operation or that has already been the argument to a Set call.InvalidOperation_NullContext = Cannot call Set on a null context</value>
  </data>
  <data name="InvalidOperation_AsyncFlowCtrlCtxMismatch" xml:space="preserve">
    <value>AsyncFlowControl objects can be used to restore flow only on the Context that had its flow suppressed.</value>
  </data>
  <data name="InvalidOperation_CannotUseAFCOtherThread" xml:space="preserve">
    <value>AsyncFlowControl object must be used on the thread where it was created.</value>
  </data>
  <data name="InvalidOperation_CannotUseAFCMultiple" xml:space="preserve">
    <value>AsyncFlowControl object can be used only once to call Undo().</value>
  </data>
  <data name="InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext" xml:space="preserve">
    <value>Send is not supported in the Windows Runtime SynchronizationContext</value>
  </data>
  <data name="ManualResetEventSlim_Disposed" xml:space="preserve">
    <value>The event has been disposed.</value>
  </data>
  <data name="ManualResetEventSlim_ctor_SpinCountOutOfRange" xml:space="preserve">
    <value>The spinCount argument must be in the range 0 to {0}, inclusive.</value>
  </data>
  <data name="ManualResetEventSlim_ctor_TooManyWaiters" xml:space="preserve">
    <value>There are too many threads currently waiting on the event. A maximum of {0} waiting threads are supported.</value>
  </data>
  <data name="SynchronizationLockException_IncorrectDispose" xml:space="preserve">
    <value>The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock.</value>
  </data>
  <data name="SynchronizationLockException_MisMatchedWrite" xml:space="preserve">
    <value>The write lock is being released without being held.</value>
  </data>
  <data name="LockRecursionException_UpgradeAfterReadNotAllowed" xml:space="preserve">
    <value>Upgradeable lock may not be acquired with read lock held.</value>
  </data>
  <data name="LockRecursionException_UpgradeAfterWriteNotAllowed" xml:space="preserve">
    <value>Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer.</value>
  </data>
  <data name="SynchronizationLockException_MisMatchedUpgrade" xml:space="preserve">
    <value>The upgradeable lock is being released without being held.</value>
  </data>
  <data name="SynchronizationLockException_MisMatchedRead" xml:space="preserve">
    <value>The read lock is being released without being held.</value>
  </data>
  <data name="LockRecursionException_WriteAfterReadNotAllowed" xml:space="preserve">
    <value>Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.</value>
  </data>
  <data name="LockRecursionException_RecursiveWriteNotAllowed" xml:space="preserve">
    <value>Recursive write lock acquisitions not allowed in this mode.</value>
  </data>
  <data name="LockRecursionException_ReadAfterWriteNotAllowed" xml:space="preserve">
    <value>A read lock may not be acquired with the write lock held in this mode.</value>
  </data>
  <data name="LockRecursionException_RecursiveUpgradeNotAllowed" xml:space="preserve">
    <value>Recursive upgradeable lock acquisitions not allowed in this mode.</value>
  </data>
  <data name="LockRecursionException_RecursiveReadNotAllowed" xml:space="preserve">
    <value>Recursive read lock acquisitions not allowed in this mode.</value>
  </data>
  <data name="SemaphoreSlim_Disposed" xml:space="preserve">
    <value>The semaphore has been disposed.</value>
  </data>
  <data name="SemaphoreSlim_Release_CountWrong" xml:space="preserve">
    <value>The releaseCount argument must be greater than zero.</value>
  </data>
  <data name="SemaphoreSlim_Wait_TimeoutWrong" xml:space="preserve">
    <value>The timeout must represent a value between -1 and Int32.MaxValue, inclusive.</value>
  </data>
  <data name="SemaphoreSlim_ctor_MaxCountWrong" xml:space="preserve">
    <value>The maximumCount argument must be a positive number. If a maximum is not required, use the constructor without a maxCount parameter.</value>
  </data>
  <data name="SemaphoreSlim_ctor_InitialCountWrong" xml:space="preserve">
    <value>The initialCount argument must be non-negative and less than or equal to the maximumCount.</value>
  </data>
  <data name="SpinLock_IsHeldByCurrentThread" xml:space="preserve">
    <value>Thread tracking is disabled.</value>
  </data>
  <data name="SpinLock_TryEnter_LockRecursionException" xml:space="preserve">
    <value>The calling thread already holds the lock.</value>
  </data>
  <data name="SpinLock_Exit_SynchronizationLockException" xml:space="preserve">
    <value>The calling thread does not hold the lock.</value>
  </data>
  <data name="SpinLock_TryReliableEnter_ArgumentException" xml:space="preserve">
    <value>The tookLock argument must be set to false before calling this method.</value>
  </data>
  <data name="SpinLock_TryEnter_ArgumentOutOfRange" xml:space="preserve">
    <value>The timeout must be a value between -1 and Int32.MaxValue, inclusive.</value>
  </data>
  <data name="TaskT_DebuggerNoResult" xml:space="preserve">
    <value>{Not yet computed}</value>
  </data>
  <data name="PlatformNotSupported_FromAsync_IAsyncResult" xml:space="preserve">
    <value>FromAsync overloads that accept an IAsyncResult parameter are not supported on this platform.  Please use a FromAsync overload that accepts a beginMethod delegate instead.</value>
  </data>
  <data name="InvalidOperation_WrongAsyncResultOrEndCalledMultiple" xml:space="preserve">
    <value>Either the IAsyncResult object did not come from the corresponding async method on this type, or the End method was called multiple times with the same IAsyncResult.</value>
  </data>
  <data name="Task_Delay_InvalidMillisecondsDelay" xml:space="preserve">
    <value>The value needs to be either -1 (signifying an infinite timeout), 0 or a positive integer.</value>
  </data>
  <data name="Task_Delay_InvalidDelay" xml:space="preserve">
    <value>The value needs to translate in milliseconds to -1 (signifying an infinite timeout), 0 or a positive integer less than or equal to Int32.MaxValue.</value>
  </data>
  <data name="Task_WaitMulti_NullTask" xml:space="preserve">
    <value>The tasks array included at least one null element.</value>
  </data>
  <data name="Task_ContinueWith_NotOnAnything" xml:space="preserve">
    <value>The specified TaskContinuationOptions excluded all continuation kinds.</value>
  </data>
  <data name="Task_RunSynchronously_AlreadyStarted" xml:space="preserve">
    <value>RunSynchronously may not be called on a task that was already started.</value>
  </data>
  <data name="Task_ThrowIfDisposed" xml:space="preserve">
    <value>The task has been disposed.</value>
  </data>
  <data name="Task_RunSynchronously_TaskCompleted" xml:space="preserve">
    <value>RunSynchronously may not be called on a task that has already completed.</value>
  </data>
  <data name="Task_RunSynchronously_Promise" xml:space="preserve">
    <value>RunSynchronously may not be called on a task not bound to a delegate, such as the task returned from an asynchronous method.</value>
  </data>
  <data name="Task_RunSynchronously_Continuation" xml:space="preserve">
    <value>RunSynchronously may not be called on a continuation task.</value>
  </data>
  <data name="Task_Start_AlreadyStarted" xml:space="preserve">
    <value>Start may not be called on a task that was already started.</value>
  </data>
  <data name="Task_Start_ContinuationTask" xml:space="preserve">
    <value>Start may not be called on a continuation task.</value>
  </data>
  <data name="Task_Start_Promise" xml:space="preserve">
    <value>Start may not be called on a promise-style task.</value>
  </data>
  <data name="Task_Start_TaskCompleted" xml:space="preserve">
    <value>Start may not be called on a task that has completed.</value>
  </data>
  <data name="TaskCanceledException_ctor_DefaultMessage" xml:space="preserve">
    <value>A task was canceled.</value>
  </data>
  <data name="TaskT_TransitionToFinal_AlreadyCompleted" xml:space="preserve">
    <value>An attempt was made to transition a task to a final state when it had already completed.</value>
  </data>
  <data name="TaskCompletionSourceT_TrySetException_NoExceptions" xml:space="preserve">
    <value>The exceptions collection was empty.</value>
  </data>
  <data name="TaskCompletionSourceT_TrySetException_NullException" xml:space="preserve">
    <value>The exceptions collection included at least one null element.</value>
  </data>
  <data name="TaskExceptionHolder_UnknownExceptionType" xml:space="preserve">
    <value>(Internal)Expected an Exception or an IEnumerable&lt;Exception&gt;</value>
  </data>
  <data name="TaskExceptionHolder_UnhandledException" xml:space="preserve">
    <value>A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result, the unobserved exception was rethrown by the finalizer thread.</value>
  </data>
  <data name="Task_MultiTaskContinuation_FireOptions" xml:space="preserve">
    <value>It is invalid to exclude specific continuation kinds for continuations off of multiple tasks.</value>
  </data>
  <data name="Task_ContinueWith_ESandLR" xml:space="preserve">
    <value>The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running.</value>
  </data>
  <data name="Task_MultiTaskContinuation_EmptyTaskList" xml:space="preserve">
    <value>The tasks argument contains no tasks.</value>
  </data>
  <data name="Task_MultiTaskContinuation_NullTask" xml:space="preserve">
    <value>The tasks argument included a null value.</value>
  </data>
  <data name="Task_FromAsync_PreferFairness" xml:space="preserve">
    <value>It is invalid to specify TaskCreationOptions.PreferFairness in calls to FromAsync.</value>
  </data>
  <data name="Task_FromAsync_LongRunning" xml:space="preserve">
    <value>It is invalid to specify TaskCreationOptions.LongRunning in calls to FromAsync.</value>
  </data>
  <data name="TaskScheduler_FromCurrentSynchronizationContext_NoCurrent" xml:space="preserve">
    <value>The current SynchronizationContext may not be used as a TaskScheduler.</value>
  </data>
  <data name="TaskScheduler_ExecuteTask_WrongTaskScheduler" xml:space="preserve">
    <value>ExecuteTask may not be called for a task which was previously queued to a different TaskScheduler.</value>
  </data>
  <data name="TaskScheduler_InconsistentStateAfterTryExecuteTaskInline" xml:space="preserve">
    <value>The TryExecuteTaskInline call to the underlying scheduler succeeded, but the task body was not invoked.</value>
  </data>
  <data name="TaskSchedulerException_ctor_DefaultMessage" xml:space="preserve">
    <value>An exception was thrown by a TaskScheduler.</value>
  </data>
  <data name="ThreadLocal_ValuesNotAvailable" xml:space="preserve">
    <value>The ThreadLocal object is not tracking values. To use the Values property, use a ThreadLocal constructor that accepts the trackAllValues parameter and set the parameter to true.</value>
  </data>
  <data name="ThreadLocal_Value_RecursiveCallsToValue" xml:space="preserve">
    <value>ValueFactory attempted to access the Value property of this instance.</value>
  </data>
  <data name="ThreadLocal_Disposed" xml:space="preserve">
    <value>The ThreadLocal object has been disposed.</value>
  </data>
  <data name="ObjectDisposed_Generic" xml:space="preserve">
    <value>Cannot access a disposed object.</value>
  </data>
  <data name="ArgumentOutOfRange_NeedNonNegOrNegative1" xml:space="preserve">
    <value>Number must be either non-negative and less than or equal to Int32.MaxValue or -1.</value>
  </data>
  <data name="ArgumentOutOfRange_TimeoutTooLarge" xml:space="preserve">
    <value>Time-out interval must be less than 2^32-2.</value>
  </data>
  <data name="ArgumentOutOfRange_PeriodTooLarge" xml:space="preserve">
    <value>Period must be less than 2^32-2.</value>
  </data>
  <data name="AggregateException_ctor_DefaultMessage" xml:space="preserve">
    <value>One or more errors occurred.</value>
  </data>
  <data name="AggregateException_ctor_InnerExceptionNull" xml:space="preserve">
    <value>An element of innerExceptions was null.</value>
  </data>
  <data name="AggregateException_InnerException" xml:space="preserve">
    <value>(Inner Exception #{0}) </value>
    <comment>This text is prepended to each inner exception description during aggregate exception formatting</comment>
  </data>
  <data name="ExecutionContext_ExceptionInAsyncLocalNotification" xml:space="preserve">
    <value>An exception was not handled in an AsyncLocal&lt;T&gt; notification callback.</value>
  </data>
</root>